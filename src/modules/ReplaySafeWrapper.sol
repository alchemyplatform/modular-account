// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.26;

import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

import {ModuleEIP712} from "./ModuleEIP712.sol";

// A contract mixin for modules that wish to use EIP-712 to wrap the hashes sent to the EIP-1271 function
// `isValidSignature`.
// This makes signatures generated by owners of contract accounts non-replayable across multiple accounts owned by
// the same owner.
abstract contract ReplaySafeWrapper is ModuleEIP712 {
    // keccak256("ReplaySafeHash(bytes32 hash)")
    bytes32 private constant _REPLAY_SAFE_HASH_TYPEHASH =
        0x294a8735843d4afb4f017c76faf3b7731def145ed0025fc9b1d5ce30adf113ff;

    /// @notice Wraps a hash in an EIP-712 envelope to prevent cross-account replay attacks.
    /// Uses the ModuleEIP712 domain separator, which includes the chainId, module address, and account address.
    /// @param account The account that will validate the message hash.
    /// @param hash The hash to wrap.
    /// @return The the replay-safe hash, computed by wrapping the input hash in an EIP-712 struct.
    function replaySafeHash(address account, bytes32 hash) public view virtual returns (bytes32) {
        return MessageHashUtils.toTypedDataHash({
            domainSeparator: _domainSeparator(account),
            structHash: _hashStruct(hash)
        });
    }

    function _hashStruct(bytes32 hash) internal pure virtual returns (bytes32) {
        bytes32 res;
        assembly ("memory-safe") {
            mstore(0x00, _REPLAY_SAFE_HASH_TYPEHASH)
            mstore(0x20, hash)
            res := keccak256(0x00, 0x40)
        }
        return res;
    }
}
